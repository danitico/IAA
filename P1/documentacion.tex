%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                       %
% La clase: 11pt o 10pt, es un draft o copia definitiva %
% Que tipo de codificacion usa, ...                     %
%                                                       %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[11pt,twoside,a4paper]{book}
\usepackage{fancyhdr}
\usepackage{fancybox}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{mathptmx}
\usepackage{amsfonts}
\usepackage{latexsym}
\usepackage{graphicx}
\usepackage{floatflt}
\usepackage{float}
\usepackage{epsfig}
\usepackage{subfigure}
\usepackage{mathrsfs}
\usepackage{amssymb}
\usepackage{hyperref}
\renewcommand{\baselinestretch}{1.2}
\graphicspath{ {./images/} }
\title{\Huge Práctica 1 IAA}
\author{Daniel Ranchal Parrado, Francisco Vera Herencia}
\date{\today}
%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                         %
% Comenzamos el documento %
%                         %
%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\maketitle
%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Algunos ajustes previos
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\renewcommand\bibname{Bibliografía}
\renewcommand\tablename{Tabla}

\pagenumbering{arabic} \fancyhf{} \pagestyle{fancy}
\fancyhead[LO]{\leftmark} % En las pginas impares, parte izquierda del encabezado, aparecer el nombre de seccin
\fancyhead[RE]{\leftmark} % En las pginas pares, parte derecha del encabezado, aparecer el nombre de captulo
\fancyhead[RO,LE]{\thepage} % Nmeros de pgina en las esquinas de los encabezados
\setlength{\headheight}{14pt}
\renewcommand{\sectionmark}[1]{\markright{{\thesection. #1}}} % Formato para la seccin: N.M. Nombre

\tableofcontents
\listoffigures

\chapter{Primer ejercicio}
\section{¿Cuántos atributos caracterizan los datos de esta base de datos?}
Los datos se caracterizan por 5 atributos, como se puede apreciar en la figura \ref{Fig1}.
\begin{figure}[H]
   \includegraphics[width=\textwidth]{attributes.png}
   \caption{atributos}
   \label{Fig1}
\end{figure}

\section{¿Se trata de regresión o clasificación?}
Se trata de una clasificación, ya que a partir de unos atributos se puede decir \
que una instancia pertenece a una clase u a otra según los valores de estos atributos.

\section{¿Cuál es el rango de valores del atributo petalwidth?¿Y su media? ¿y su desviación típica?}
Respecto al rango de valores del atributo petalwidth (anchura del pétalo), vendrá \
dado por los valores mínimo y máximo registrado, por lo que, según la figura \
\ref{Fig2} este rango será [0'1,2'5]. En la misma imagen también se indica la media y su desviación típica, cuyos valores son  1'199 y 0'763, respectivamente.
\begin{figure}[H]
	\includegraphics[width=\textwidth]{petalwidth.png}
	\caption{Rango, media y desviación típica de los datos del atributo petalwidth}
	\label{Fig2}
\end{figure}

\section{Determinar que atributo permite discriminar linealmente entre la clase iris-setosa y las otras dos clases}
\begin{figure}[H]
	\includegraphics[width=\textwidth]{Plot.png}
	\caption{Gráfico en el que se diferencian las diferentes instancias según el ancho y la longitud del pétalo}
	\label{Fig3}
\end{figure}
Como se puede observer en la figura \ref{Fig3}, se puede diferenciar con bastante\
exactitud la clase iris-setosa y el resto de la clases. Para poder diferenciarlas de esta\
manera se puede utilizar los atributos petallenght o petalwidth.

\section{¿Es posible separar linealmente la clase iris-versicolor de la clase iris-virginica?}
Como se puede ver en la figura \ref{Fig3}, la clases iris-versicolo y la clase iris-virginica se pueden\
separar linealmente utilizando los atributos petallenght y petalwidth.

\section{¿Con qué dos atributos te quedarías para discriminar entre las tres clases del problema?}
Las tres clases se pueden discriminar utilizando los atributos petallenght y petalwidth\
tal y como se puede observar en la figura \ref{Fig3}.

\section{¿Que diferencia hay entre instancias Distinct y \break Unique?}
Distinct determina el número de diferentes valores que se pueden dar en un atributo,\
mientras que Unique determina el número de instancias que tienen atributos con valores\
únicos que otras instancias no tienen.


\chapter{Segundo ejercicio}

\section{Aplique el filtro filters/unsupervised/attribute/NominalToBinary y describa como quedan ahora los atributos.}
\begin{figure}[H]
	\includegraphics[width=\textwidth]{ejercicio2.png}
	\caption{Atributos antes de aplicar el filtro}
	\label{Fig4}
\end{figure}

Después de aplicar el filtro NominalToBinary, habrá los siguiente atributos:

\begin{figure}[H]
	\includegraphics[width=\textwidth]{ejercicio2_1.png}
	\caption{Atributos después de aplicar el filtro}
	\label{Fig5}
\end{figure}

\section{¿Podría saber con antelación el número de atributos finales al aplicar este filtro?}
Cada atributo tiene una serie de etiquetas. Como estos atributos son de tipo nominal,
cada etiqueta, al aplicar el filtro, se convertirán en un atributo en el caso que
este puedo tomar 3 o más valores. Como se puede ver en la figura \ref{Fig5}, el
atributo age\_gt\_60, airBoneGap, boneAbnormal y bser solo pueden tomar dos valores
distintos, por lo que en el dataset este grupo atributos se comportarán como uno
y los valores de estos serán 0 y 1. En el resto de atributos menos el último de ellos,
estos atributos nominales pueden tomar más de tres valores, por lo que en el dataset
se crearán tantos atributos como valores pueda tomar este.

\section{¿Que ha pasado con algunos atributos nominales?}
Como se ha comentado en la pregunta anterior, aquellos atributos nominales que puedan
tomar dos valores o menos no conllevan en crear un atributo por cada valor que puede tomar.


\chapter{Tercer ejercicio}
\section{Divida el dataset en train y test mediante un 3-fold. Describa el proceso realizado.}
Para poder realizar un 3-fold hay que seguir los siguientes pasos. El primero de ellos
es determinar la configuración del filtro.

\begin{figure}[H]
	\includegraphics[width=\textwidth]{ejercicio3_1.png}
	\caption{Configuración del filtro StratifiedRemoveFolds para obtener el set de generalización para 3-Fold}
	\label{Fig13}
\end{figure}

Como se puede observar en la figura \ref{Fig13}, para obtener el conjunto de
generalización, se especifica que escogeremos el fold número 1. Es decir, se escogerá
un fold de tres. Como solo queremos un fold, se pone a false invertSelection. En el
caso que en esa ultima configuración se ponga true, se cogerán todos los folds menos el
primero. Estos dos folds serían el conjunto de entrenamiento. Este ultimo paso se puede
ver en la figura \ref{Fig14}.

\begin{figure}[H]
	\includegraphics[width=\textwidth]{ejercicio3_2.png}
	\caption{Configuración del filtro StratifiedRemoveFolds para obtener el set de entrenamiento para 3-Fold}
	\label{Fig14}
\end{figure}

Para terminar de hacer un 3-fold. Habría que repetir estos pasos anteriores pero
el fold que elegimos. Quedaría por coger el fold 2, guardaríamos el set de
entrenamiento y de generalización y lo mismo con el último fold.

% reobiegrfjbirepgbebgjjkbsfddddsjbkgfjbgffgbj
% Para la primera parte, seleccionamos fold 1 y 3 numfolds -> test
%                                           1   3 numfolds,invert ->training
% Y así cambiando el numero de fold que queremos coger

\section{Divida el dataset en train y test mediante un 4-holdOut con un75\% train y 25\% test.}
Para poder realizar un 4-holdOut con los porcentajes propuestos hay que realizar la
siguiente configuración del filtro, como se puede ver en la figura \ref{Fig15}.

\begin{figure}[H]
	\includegraphics[width=\textwidth]{ejercicio3_3.png}
	\caption{Configuración del filtro StratifiedRemoveFolds para obtener el set de generalización para 4-HoldOut}
	\label{Fig15}
\end{figure}

Como nos piden que el conjunto de generalización sea un 25\%, debemos de repartir el conjunto
de datos en 4 folds y coger uno de ellos para test. Como HoldOut coge Folds de los datos
aleatoriamente, hay que fijar una semilla para generar numeros aleatorios, y por lo tanto
coger Folds aleatorios. Para coger el resto de los folds para el conjunto de entrenamiento,
pondremos la opción invertSelection a true. Hay que tener en cuenta que hay mantener la
misma semilla en la misma iteración de HoldOut.

En distintas iteraciones de HoldOut, hay que cambiar el número de la semilla aleatoria,
ya que si no se tendrá todo el rato el algoritmo k-fold.

\chapter{Cuarto ejercicio}
\section{Construya a partir del fichero dataset371.csv un \break fichero .arff para Weka. Ponga nombres de
\break atributos descriptivos y use las herramientas que \break considere necesarias}
Para poder construir un fichero .arff a partir de un .csv, primero hay que cargar
este último en weka. Para ello, le daremos a la pestaña de open y buscaremos los
archivos de esta extensión y escogeremos el archivo dataset371.csv, como se puede
observar en la figura \ref{Fig6}.

\begin{figure}[H]
   \begin{center}
	     \includegraphics[scale=1]{ejercicio4_1.png}
   \end{center}
	\caption{Abriendo el archivo dataset371.csv}
	\label{Fig6}
\end{figure}

Una vez que tenemos cargado el fichero .csv en weka, solo hace falta guardarlo con
formato .arrf. Para ello solo hace falta irse a la pestaña Save, donde guadaremos
los datos con la extensión .arff. Este proceso se puede ver en la figura \ref{Fig7}.

\begin{figure}[H]
   \begin{center}
      \includegraphics[width=\textwidth]{ejercicio4_2.png}
   \end{center}
	\caption{Guardando el archivo en formato .arff}
	\label{Fig7}
\end{figure}

Para poder editar el nombre de los distintos atributos, solamente hay que irse a la
pestaña Edit, tal y como se puede ver en la figura \ref{Fig8}.
En este caso no se va a modificar ningún nombre de los atributos ya que cada uno
de ellos expresa de una manera concisa su significado.

\begin{figure}[H]
   \includegraphics[width=\textwidth]{ejercicio4_3.png}
	\caption{Cambiando el nombre de un atributo}
	\label{Fig8}
\end{figure}


\section{Describa de forma concienzuda tanto los atributos como las clases de la base de datos.}
\begin{figure}[H]
   \includegraphics[width=\textwidth]{ejercicio4_4.png}
	\caption{Atributos y su tipo de la base de datos dataset371}
	\label{Fig9}
\end{figure}
Como se puede ver en la figura \ref{Fig9}, se distiguen 7 atributos, de los cuales
5 de ellos son numéricos y el resto son nominales. El atributo id no tiene en esta
base de datos no tiene ningún significado, ya que solo enumera cada una de las instancias
que hay. El segundo atributo cuyo nombre es bone\_lenght y el cuál es númerico,
determina la longitud del hueso de la criatura, la cuál está normalizada entre 0
y 1. El tercer atributo, de tipo numérico, que está denominado como rotting\_flesh
representa el porcentaje de este en un rango de 0 a 1.
El atributo hair\_lenght, de tipo numérico, representa la longitud del pelo, cuyos
datos están normalizados entre 0 y 1.
El atributo has\_soul es de tipo numérico y representa un porcentaje que está normalizado
entre 0 y 1. El atribito color, como su propio nombre indica, determina el color
de la criatura. Es un atributo nominal y puede tomar los valores whhite, black, clear,
blue, green y blood.
El último atributo, llamado type, determina el tipo de la criatura, es decir, nos indica
a que clase pertenece. Es de tipo nominal y puede tomar los valores Ghost, Goblin y Ghoul.

\section{Observe si hay atributos identificadores. Si no existen diga por qué.}
Se puede descubrir si hay o no hay con el filtro remove useless.
No se distingue ningún atributo identificador en la base de datos ya que ninguno
de ellos tiene valores para poder diferenciarse de manera única unos de otros. Se puede
observar perfectamente que existe un atributo llamado Id, cuyo trabajo es identificador
pero la única función que realiza es enumerar las distintas instancias.

\section{¿Hay alguna relación que sea visualmente \break significativa?}
\begin{figure}[H]
   \includegraphics[width=\textwidth]{ejercicio4_5.png}
	\caption{Gráficas de la base de datos dataset371}
	\label{Fig10}
\end{figure}
Como se puede observar en la figura \ref{Fig10}, no se puede visualizar o reconocer
algún hecho de una importancia significativa respecto las clases de las instancias
y los diferentes atributos.

\chapter{Quinto ejercicio}
\section{Describa con sus propias palabras los siguientes \break filtros No Supervisados y describa cómo quedan los datos al aplicarlos.}
\subsection{filters/unsupervised/attribute/Normalize}
Este filtro normaliza los valores de un atributo entre 0 y 1. En este base de datos
no se puede aplicar ya que todos los datos ya están normalizados en este rango, por
lo que a continuación se va a crear una base de datos ficticia.

\begin{figure}[H]
   \includegraphics[width=\textwidth]{ejercicio5_1.png}
	\caption{Antes de aplicar el filtro Normalize}
	\label{Fig11}
\end{figure}
\begin{figure}[H]
   \includegraphics[width=\textwidth]{ejercicio5_2.png}
	\caption{Después de aplicar el filtro Normalize}
	\label{Fig12}
\end{figure}

\subsection{filters/unsupervised/attribute/ReplaceMissingValues}
Reemplaza todos los valores indefinidos por la moda en el caso de que
sea un atributo nominal o la media aritmética si es un atributo numérico. Para comprobar su efecto creamos una nueva instancia con valores vacíos en el fichero Criaturas Tenebrosas como se aprecia en la figura \ref{Fig13}.

\begin{figure}[H]
   \includegraphics[width=\textwidth]{ReplaceMissingValues1.png}
	\caption{Antes de aplicar el filtro ReplaceMissingValues}
	\label{Fig13}
\end{figure}
\begin{figure}[H]
   \includegraphics[width=\textwidth]{ReplaceMissingValues2.png}
	\caption{Después de aplicar el filtro ReplaceMissingValues}
	\label{Fig14}
\end{figure}

\subsection{filters/unsupervised/attributes/NominalToBinary}
Transforma los valores nominales de un atributo en un vector cuyas coordenadas son binarias. En el fichero Criaturas Tenebrosas proporcionado, su efecto sería convertir el color de la criatura, que es una variable nominal en tantas variables binarias como valores distintos existan.

\begin{figure}[H]
   \includegraphics[width=\textwidth]{NominaltoBinary1.png}
	\caption{Antes de aplicar el filtro NominaltoBinary}
	\label{Fig15}
\end{figure}
\begin{figure}[H]
   \includegraphics[width=\textwidth]{NominaltoBinary2.png}
	\caption{Después de aplicar el filtro NominaltoBinary}
	\label{Fig16}
\end{figure}

\subsection{filters/unsupervised/instance/RemoveDuplicates}
Borra todas las instancias duplicadas dejando solo una de ellas, que ahora será única. Este ejemplo se puede observar en los datos del fichero iris.

\begin{figure}[H]
   \includegraphics[width=\textwidth]{RemoveDuplicates1.png}
	\caption{Antes de aplicar el filtro RemoveDuplicates}
	\label{Fig17}
\end{figure}
\begin{figure}[H]
   \includegraphics[width=\textwidth]{RemoveDuplicates2.png}
	\caption{Después de aplicar el filtro RemoveDuplicates}
	\label{Fig18}
\end{figure}

\subsection{filters/unsupervised/instance/Resample}
Obtiene un subconjunto del conjunto inicial de forma aleatoria.
Para comprobar el efecto de este filtro usaremos el conjunto iris. Como se puede apreciar en \ref{Fig19}, nos encontramos con la base de datos en su estado inicial y nos disponemos a aplicar el filtro para reducir la muestra a un 90\% aleatorio sin reemplazo. En \ref{Fig20} se observan los datos del subconjunto resultante.

\begin{figure}[H]
   \includegraphics[width=\textwidth]{Resample1.png}
	\caption{Antes de aplicar el filtro Resample}
	\label{Fig19}
\end{figure}
\begin{figure}[H]
   \includegraphics[width=\textwidth]{Resample2.png}
	\caption{Después de aplicar el filtro Resample}
	\label{Fig20}
\end{figure}

\subsection{filters/unsupervised/attribute/Remove}
Borra un conjunto de atributos del fichero de datos. Dicho conjunto se debe especificar explícitamente como argumento del filtro, indicando los números de los atributos entre comas o rangos de atributos entre guiones. En el ejemplo de las figuras se puede apreciar como se consiguen borrar los atributos 2, 3 y 4.

\begin{figure}[H]
   \includegraphics[width=\textwidth]{remove1.png}
	\caption{Antes de aplicar el filtro Remove}
	\label{Fig21}
\end{figure}
\begin{figure}[H]
   \includegraphics[width=\textwidth]{remove2.png}
	\caption{Después de aplicar el filtro Remove}
	\label{Fig22}
\end{figure}

\subsection{filters/unsupervised/attribute/RemoveUseless}
Elimina atributos que oscilan menos que un nivel de variación. Es útil para
eliminar atributos constantes o con un rango muy pequeño. Como parámetro toma el máximo porcentaje de variación permitido, si este valor obtenido es mayor que la variación
obtenida la muestra es eliminada.

\begin{figure}[H]
   \includegraphics[width=\textwidth]{RemoveUseless1.png}
	\caption{Antes de aplicar el filtro RemoveUseless}
	\label{Fig23}
\end{figure}
\begin{figure}[H]
   \includegraphics[width=\textwidth]{RemoveUseless2.png}
	\caption{Después de aplicar el filtro RemoveUseless}
	\label{Fig24}
\end{figure}

\chapter{Conclusiones y discusión}

En primer lugar, se aprecia un fuerte problema en el hardware de este servidor \
debido al cuello de botella que aparece al ejecutar los bencharmarks en la CPU, \
esto es fácil de comprender, debido a que la concurrencia toma protagonismo en \
estos tests, con algunos fijándola en valores como 10 peticiones concurrentes. \
Esta teoría es afirmada por las gráficas mostradas, donde vemos fácilmente como \
el procesador llega a funcionar a niveles cercanos al 100\% de utilidad durante \
la duración de las pruebas efectuadas.\newline \newline
\indent Además de esto, otro factor determinante en este caso es el bajo número de \
transferencias por segundo que el servidor es capaz de aguantar y que está \
fuertemente relacionado con el almacenamiento del mismo en el cual se almacenan \
las fotografías que sirven como cargas de prueba, el cual en ninguna prueba es \
capaz de llegar ni tan siquiera a la unidad, y eso es algo que los encargados \
de testear su funcionamiento hemos conocido de primera mano al tener que \
esperar grandes cantidades de tiempo a que todos los tests fueran completados \
varias veces con éxito. En cuanto a las peticiones por segundo, casi nunca \
superan el cuarto de unidad, hecho que no hace más que corroborar las \
afirmaciones anteriores. \newline

% \begin{figure}[H]
%    \includegraphics[width=\textwidth]{grafica1.jpg}
%    \caption{Transferencias por Segundo, peticiones por segundo \
%    y tiempo empleado en un grupo de peticiones concurrentes.}
%    \label{Fig1}
% \end{figure}

Si contemplamos el gráfico pipo, nos damos cuenta de que el número de \
peticiones por segundo, al ser un parámetro íntimamente ligado al hardware \
sobre el que se esté ejecutando el banco de pruebas escogido, apenas varía, \
puesto que la CPU solo es capaz de ejecutar un número determinado de ellas, \
siendo todas iguales. Lo interesante de este gráfico, es ver como el tiempo \
empleado en servir un grupo de peticiones concurrentes decae a lo largo de las \
cinco ejecuciones del test. Tras indagar en los motivos de este aumento del \
rendimiento, nos damos cuenta de que Azure es un servicio de computación en la \
nube que alardea de proveer de una caché inteligente a sus máquinas virtuales \
que estén corriendo en sus servidores, como es nuestro caso, eso por ello por \
lo que se aprecia esta mejora en el rendimiento, debido a que gran parte de los \
datos que son necesarios para la ejecución de la prueba, ya están cargados en \
la caché del servidor y son accesibles de manera mucho más rápida para la \
siguiente ejecución. \newline \newline
% \indent Si contemplamos las gráficas \ref{Fig2}, \ref{Fig3} y \ref{Fig4}, no hay gran \
diferencia entre ellas en cuanto al parámetro de medición, el número de \
transferencias por segundo del disco del servidor. Para analizar las gráficas, \
recordemos que estos datos han sido tomados con el monitor sar, mientras que ab \
era ejecutado, tras ello, se ha realizado la media aritmética de los valores \
del parámetro interesado que sar tomaba cada 10 segundos durante la ejecución \
del test. Entonces, podemos ver como apenas hay diferencias significativas \
% entre las ejecuciones, por ejemplo, en la gráfica \ref{Fig2}, vemos como\
normalmente el test de menor concurrencia y menos repeticiones\
(línea amarilla), tarda normalmente menos tiempo que el test con más \
concurrencia y el doble de repeticiones (línea verde), aunque veamos \
ejecuciones donde estas posiciones se inviertan, esto se debe más al margen de \
% error que a otra cosa. En cuanto a la gráfica \ref{Fig4}, la referida a los \
resultados del mosaico de imágenes pequeñas, observamos como la línea azul, \
la correspondiente con el uso de https, lo cual es curioso debido a que en las \
dos últimas pruebas se habían mantenido por debajo, sin embargo, no es de \
preocupación, ya que no se aprecian diferencias muy significativas en la \
mayoría de las ejecuciones, sin embargo, vemos como esa línea sube hasta una \
transferencia por segundo en la segunda ejecución, lo cual es muy significativo.
La imagen general de estas pruebas es que mientras más grandes sean las \
imágenes del banco de pruebas, menos transferencias por segundo se llevarán a \
cabo, lo cual es lógico, puesto que son archivos más grandes. \newline
Si analizamos ahora el uso de la red del servidor, aquí no tenemos ningún \
problema de cuello de botella, Azure nos proporciona una velocidad de conexión \
veloz y estable y no es algo que un administrador de un servidor pequeño como \
este tenga que preocuparse, por supuesto, mientras más exigente sea el test con \
la CPU, lo será con el uso de red que éste requerirá, puesto que estamos \
hablando de un servidor web. \newline \newline
En conclusión, hemos detectado que nuestro cuello de botella es una CPU que a \
pesar de ser muy potente en el conjunto de todos sus núcleos, apenas aguantaría \
un servidor web pequeño como este ante un importante número de peticiones al \
servidor, esto es debido a que la cuenta de estudiante de Microsoft Azure que \
estamos empleando para este trabajo solo ofrece un núcleo de procesador, \
potente, si, pero que flaquea en tareas que involucren una alta concurrencia \
de peticiones. Y es que ese es el argumento por el cual los procesadores \
empleados para su uso en servidores de cualquier tipo suelen contar con un \
gran número de núcleos tanto físicos como lógicos y poder procesar rápidamente \
todas las peticiones que reciba. En cuanto a la referenciación, sabemos que los \
resultados aquí mostrados corresponden con los de un servidor de \
especificaciones limitadas, útil para este propósito, pero de limitado uso, y \
es que, tras haber ejecutado numerosos bancos de pruebas centrados en multitud \
de aspectos de un sistema informático, entre ellos Apache Benchmark, hemos \
encontrado que fácilmente, un ordenador doméstico con todos sus núcleos \
activados puede sobrepasar fácilmente el rendimiento de este procesador, \
organizaciones como SPEC tienen precisamente esa función, la de examinar este \
tipo de equipos informáticos para poder realizar comparativas, lo cual nos es \
muy útil a la hora de sacar conclusiones sobre el desempeño de este hardware. \
Por último, hemos de decir, que Microsoft Azure es una útil herramienta para \
alojar cualquier tipo de servidor o aplicación web y que nos ha sido muy útil \
para la realización de este trabajo y que, previo pago de la capacidad \
necesaria, se puede obtener muchísima potencia de cómputo de ella.

\section{Cuestiones}
\begin{itemize}
  \item \textbf{¿Qué factores pueden hacer variar el tiempo de respuesta a la\
   hora de realizar una petición? ¿Como puede el servidor mejorar este?}\newline
   El tiempo de respuesta puede variar por factores, tanto del lado del cliente\
   como del del servidor. Del lado del cliente puede variar por la lejanía al\
   centro del servidor o el estado de la conexión a internet. Del lado del\
   servidor, la cantidad de llamadas en un instante y el hardware son las\
   causas de esta variación. El servidor puede mejorar el tiempo de respuesta\
   variando el hardware, viendo cual es el cuello de botella y mejorando sus\
   componentes, de tal manera que pueda encontrar un punto en el que sea capaz\
   de encontrar una capacidad de cómputo suficiente para sus peticiones.

  \item \textbf{¿Por qué repetimos varias veces el test de ab y\
   con varias configuraciones?}\newline
   Al ejecutar las distintas configuraciones de ab varias veces estamos\
   logrando dos cosas: la primera, bajo una misma configuración de prueba\
   tomamos varias medidas en cada una de las cinco ejecuciones del test y\
   aplicamos la media artimética sobre cada una de ellas con el fin de obtener\
   la máxima fidelidad de los datos a una hipotética situación real de trabajo\
   del servidor. El segundo logro corresponde con el comprobamiento del\
   funcionamiento del servidor bajo diferentes condiciones de trabajo, por\
   ejemplo variando la concurrencia de trabajos que ha de procesar. Combinando\
   estos dos procedimientos, nos hacemos una idea de la potencia que tiene el\
   servidor y su desempeño en una situación real.

  \item \textbf{Teniendo en cuenta todos los datos extraidos del servidor\
   web, ¿Es rentable y de utilidad Tomcat?}\newline
   Respecto a la utilidad, Tomcat restringe o más bien, imposibilita aquellas \
   aplicaciones web que no sean hechas con Java y el lenguaje de marcado html,\
   y por lo tanto, deja atrás lenguajes útiles para este campo de la informática\
   como PHP. Respecto a la correcta configuración de Tomcat, es muy fácil y nos\
   proporciona herramientas ya mencionadas en la memoria. Pero el mayor problema\
   para utilizar Tomcat en un sistema basado en Linux es la instalación de Java\
   Virtual Machine, es bastante complicado de instalar y por ello, a lo mejor,\
   Tomcat no es tán utilizado como nginx, apache2 o httpd.
   Teniendo en cuenta las características del servidor que sirve Tomcat, es lo\
   suficientemente bueno para soportar la funcionalidad de los archivos jsp.

\end{itemize}

%% APENDICES
%\ \newpage
% \appendix

\renewcommand{\baselinestretch}{1.2}

% BIBLIOGRAFIA
\bibliography{biblio}
\bibliographystyle{unsrt}
\nocite{*}
\end{document}
